<template>
  <div style="flex-direction: column;">
    <text style="font-size:24px;text-align:center;margin-top:10px;">{{ now }}</text>
    <div style="flex-direction:column;justify-content:center;align-items:center;flex:1;">
      <text style="font-size:64px;font-weight:bold;margin-bottom:8px;">{{ grid }}</text>
      <text style="font-size:28px;color:#666666;margin-bottom:12px;">{{ lat }}, {{ lon }}</text>
    </div>
  </div>
  </template>

<script>
import geolocation from "@system.geolocation"

function index2Char(idx) {
  return String.fromCharCode("A".charCodeAt(0) + idx)
}

function getCode(lon, lat) {
  let field1 = Math.floor((180 + lon) / 20)
  let field2 = Math.floor((90 + lat) / 10)
  let Field = index2Char(field1) + index2Char(field2)
  let square1 = Math.floor(Math.floor(lon + 180) % 20 / 2)
  let square2 = Math.floor(lat + 90) % 10
  let code = Field + square1 + square2
  let block1 = Math.floor((lon - Math.floor(lon / 2) * 2) * 60 / 5)
  let block2 = Math.floor((lat - Math.floor(lat)) * 60 / 2.5)
  code = code + index2Char(block1) + index2Char(block2)
  return code
}

export default {
  private: {
    now: "",
    lat: "--",
    lon: "--",
    grid: "--",
    timerClock: 0,
    timerLocation: 0,
    gcCounter: 0,
    active: true,
    locating: false,
    retry: 0,
    subscribed: false
  },
  initGeo() {
    if (!geolocation || typeof geolocation.subscribe !== "function") return
    if (this.subscribed) return
    geolocation.subscribe({
      interval: 2000,
      callback: data => {
        const lat = Number(data.latitude)
        const lon = Number(data.longitude)
        if (Number.isFinite(lat) && Number.isFinite(lon)) {
          const latStr = lat.toFixed(5)
          const lonStr = lon.toFixed(5)
          const changed = (latStr !== this.lat || lonStr !== this.lon)
          if (changed) {
            const newGrid = getCode(lon, lat)
            this.lat = latStr
            this.lon = lonStr
            this.grid = newGrid
          }
          this.retry = 0
        }
      },
      fail: () => { this.retry++ }
    })
    this.subscribed = true
  },
  unsubscribeGeo() {
    if (this.subscribed && geolocation && typeof geolocation.unsubscribe === "function") {
      geolocation.unsubscribe()
      this.subscribed = false
    }
  },

  onInit() {
    this.updateTime()
    setTimeout(() => this.initGeo(), 300)
    this.startTimers()
  },
  onShow() {
    this.active = true
    this.startTimers()
  },
  onHide() {
    this.active = false
    this.stopTimers()
  },
  onDestroy() {
    this.stopTimers()
  },

  updateTime() {
    const d = new Date()
    const pad = n => n < 10 ? "0" + n : "" + n
    this.now = `${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`
  },

  refresh() {
    if (this.locating) return
    this.locating = true
    if (!geolocation || typeof geolocation.getLocation !== "function") {
      this.locating = false
      this.scheduleLocation()
      return
    }
    geolocation.getLocation({
      timeout: 2000,
      success: data => {
        const lat = Number(data.latitude)
        const lon = Number(data.longitude)
        const latStr = lat.toFixed(5)
        const lonStr = lon.toFixed(5)
        if (Number.isFinite(lat) && Number.isFinite(lon)) {
          const changed = (latStr !== this.lat || lonStr !== this.lon)
          if (changed) {
            const newGrid = getCode(lon, lat)
            this.lat = latStr
            this.lon = lonStr
            this.grid = newGrid
          }
          this.retry = 0
        }
        this.gcCounter++
        if (this.gcCounter % 60 === 0 && global && typeof global.runGC === "function") {
          global.runGC()
        }
      },
      fail: () => { this.retry++ },
      complete: () => {
        this.locating = false
        this.scheduleLocation()
      }
    })
  },
  startTimers() {
    if (!this.timerClock) this.timerClock = setInterval(() => this.updateTime(), 1000)
  },
  stopTimers() {
    if (this.timerClock) { clearInterval(this.timerClock); this.timerClock = 0 }
    if (this.timerLocation) { clearTimeout(this.timerLocation); this.timerLocation = 0 }
    if (typeof this.unsubscribeGeo === "function") this.unsubscribeGeo()
  },
  scheduleLocation() {
    if (this.timerLocation) { clearTimeout(this.timerLocation); this.timerLocation = 0 }
    const delay = Math.min(60000, 5000 * Math.pow(2, this.retry))
    const jitter = Math.floor(Math.random() * 500)
    this.timerLocation = setTimeout(() => this.refresh(), delay + jitter)
  }
}
</script>

<style>
</style>
